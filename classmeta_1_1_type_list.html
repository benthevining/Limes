<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Limes: meta::TypeList&lt; Types &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Limes
   </div>
   <div id="projectbrief">C++utilitiesandbuildingblocks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmeta_1_1_type_list.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmeta_1_1_type_list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">meta::TypeList&lt; Types &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A compile-time list of types that can be manipulated.  
 <a href="classmeta_1_1_type_list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_type_list_8h_source.html">TypeList.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a497620ac6e35976d49a8dc897a43c728"><td class="memTemplParams" colspan="2">template&lt;typename... TypesToAdd&gt; </td></tr>
<tr class="memitem:a497620ac6e35976d49a8dc897a43c728"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a497620ac6e35976d49a8dc897a43c728">add</a> = typelist::add_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToAdd... &gt;</td></tr>
<tr class="memdesc:a497620ac6e35976d49a8dc897a43c728"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with the given types appended to the end.  <a href="classmeta_1_1_type_list.html#a497620ac6e35976d49a8dc897a43c728">More...</a><br /></td></tr>
<tr class="separator:a497620ac6e35976d49a8dc897a43c728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7aed2a8915342ded7f77d1d4332718"><td class="memTemplParams" colspan="2">template&lt;class Other &gt; </td></tr>
<tr class="memitem:aaa7aed2a8915342ded7f77d1d4332718"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#aaa7aed2a8915342ded7f77d1d4332718">add_from</a> = typelist::add_from_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other &gt;</td></tr>
<tr class="memdesc:aaa7aed2a8915342ded7f77d1d4332718"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with types added from another <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#aaa7aed2a8915342ded7f77d1d4332718">More...</a><br /></td></tr>
<tr class="separator:aaa7aed2a8915342ded7f77d1d4332718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda7e9eb484975a96ac7650e2ea4a110"><td class="memTemplParams" colspan="2">template&lt;typename... TypesToAdd&gt; </td></tr>
<tr class="memitem:afda7e9eb484975a96ac7650e2ea4a110"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#afda7e9eb484975a96ac7650e2ea4a110">addIfAbsent</a> = typelist::addIfAbsent_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToAdd... &gt;</td></tr>
<tr class="memdesc:afda7e9eb484975a96ac7650e2ea4a110"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each type in the passed list of types, adds it to the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> if it was not already in the list.  <a href="classmeta_1_1_type_list.html#afda7e9eb484975a96ac7650e2ea4a110">More...</a><br /></td></tr>
<tr class="separator:afda7e9eb484975a96ac7650e2ea4a110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c811cbb96e424939618e06824bd514"><td class="memTemplParams" colspan="2">template&lt;typename ToAppend &gt; </td></tr>
<tr class="memitem:ae3c811cbb96e424939618e06824bd514"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ae3c811cbb96e424939618e06824bd514">append</a> = typelist::append_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, ToAppend &gt;</td></tr>
<tr class="memdesc:ae3c811cbb96e424939618e06824bd514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a type to the end of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#ae3c811cbb96e424939618e06824bd514">More...</a><br /></td></tr>
<tr class="separator:ae3c811cbb96e424939618e06824bd514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0c46f8256995053c560cbf549192a2"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class T&gt; </td></tr>
<tr class="memitem:a0d0c46f8256995053c560cbf549192a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a0d0c46f8256995053c560cbf549192a2">apply_to</a> = T&lt; Types... &gt;</td></tr>
<tr class="memdesc:a0d0c46f8256995053c560cbf549192a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the types in this typelist to another class template, as its template arguments.  <a href="classmeta_1_1_type_list.html#a0d0c46f8256995053c560cbf549192a2">More...</a><br /></td></tr>
<tr class="separator:a0d0c46f8256995053c560cbf549192a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3937cad484c565e75f456d1fcee73784"><td class="memTemplParams" colspan="2">template&lt;size_t Index&gt; </td></tr>
<tr class="memitem:a3937cad484c565e75f456d1fcee73784"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a> = typelist::get_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index &gt;</td></tr>
<tr class="memdesc:a3937cad484c565e75f456d1fcee73784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of an element of the list at the specified index.  <a href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">More...</a><br /></td></tr>
<tr class="separator:a3937cad484c565e75f456d1fcee73784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26a020d3c96a0838431334afb15cf3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ab26a020d3c96a0838431334afb15cf3d">back</a> = typelist::get_last_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> &gt;</td></tr>
<tr class="memdesc:ab26a020d3c96a0838431334afb15cf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the last element in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#ab26a020d3c96a0838431334afb15cf3d">More...</a><br /></td></tr>
<tr class="separator:ab26a020d3c96a0838431334afb15cf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665752851436124da071d3aa67c997d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a665752851436124da071d3aa67c997d6">clear</a> = <a class="el" href="classmeta_1_1_type_list.html">TypeList</a>&lt;&gt;</td></tr>
<tr class="memdesc:a665752851436124da071d3aa67c997d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#a665752851436124da071d3aa67c997d6">More...</a><br /></td></tr>
<tr class="separator:a665752851436124da071d3aa67c997d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cde21ab3769005ac8f1b0163c970218"><td class="memTemplParams" colspan="2">template&lt;class Other &gt; </td></tr>
<tr class="memitem:a1cde21ab3769005ac8f1b0163c970218"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a1cde21ab3769005ac8f1b0163c970218">common_with</a> = typelist::common_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other &gt;</td></tr>
<tr class="memdesc:a1cde21ab3769005ac8f1b0163c970218"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that contains only types that were present in the original list and the passed list <code>Other</code> .  <a href="classmeta_1_1_type_list.html#a1cde21ab3769005ac8f1b0163c970218">More...</a><br /></td></tr>
<tr class="separator:a1cde21ab3769005ac8f1b0163c970218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3461bc7c00934b6b80dcfaeee9a329ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a3461bc7c00934b6b80dcfaeee9a329ac">front</a> = typelist::get_first_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> &gt;</td></tr>
<tr class="memdesc:a3461bc7c00934b6b80dcfaeee9a329ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the first element in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#a3461bc7c00934b6b80dcfaeee9a329ac">More...</a><br /></td></tr>
<tr class="separator:a3461bc7c00934b6b80dcfaeee9a329ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28862d6c3bb64250c2c4f12347c84d88"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename ToInsert &gt; </td></tr>
<tr class="memitem:a28862d6c3bb64250c2c4f12347c84d88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a28862d6c3bb64250c2c4f12347c84d88">insert_at</a> = typelist::insert_at_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index, ToInsert &gt;</td></tr>
<tr class="memdesc:a28862d6c3bb64250c2c4f12347c84d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> at the given <code>Index</code> .  <a href="classmeta_1_1_type_list.html#a28862d6c3bb64250c2c4f12347c84d88">More...</a><br /></td></tr>
<tr class="separator:a28862d6c3bb64250c2c4f12347c84d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f923abd9d31f45679cdfe766601bd4b"><td class="memTemplParams" colspan="2">template&lt;class Other &gt; </td></tr>
<tr class="memitem:a4f923abd9d31f45679cdfe766601bd4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a4f923abd9d31f45679cdfe766601bd4b">not_in</a> = typelist::not_in_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other &gt;</td></tr>
<tr class="memdesc:a4f923abd9d31f45679cdfe766601bd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that contains only types that were present in the original list and not in the passed list <code>Other</code> .  <a href="classmeta_1_1_type_list.html#a4f923abd9d31f45679cdfe766601bd4b">More...</a><br /></td></tr>
<tr class="separator:a4f923abd9d31f45679cdfe766601bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3107b564759c17110c888f516c4b893"><td class="memTemplParams" colspan="2">template&lt;typename ToPrepend &gt; </td></tr>
<tr class="memitem:ac3107b564759c17110c888f516c4b893"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ac3107b564759c17110c888f516c4b893">prepend</a> = typelist::prepend_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, ToPrepend &gt;</td></tr>
<tr class="memdesc:ac3107b564759c17110c888f516c4b893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a type to the beginning of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#ac3107b564759c17110c888f516c4b893">More...</a><br /></td></tr>
<tr class="separator:ac3107b564759c17110c888f516c4b893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fe33567c0c519098b0a70c42d7d0fd"><td class="memTemplParams" colspan="2">template&lt;typename... TypesToRemove&gt; </td></tr>
<tr class="memitem:a96fe33567c0c519098b0a70c42d7d0fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a96fe33567c0c519098b0a70c42d7d0fd">remove</a> = typelist::remove_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToRemove... &gt;</td></tr>
<tr class="memdesc:a96fe33567c0c519098b0a70c42d7d0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with all occurances of the passed types removed.  <a href="classmeta_1_1_type_list.html#a96fe33567c0c519098b0a70c42d7d0fd">More...</a><br /></td></tr>
<tr class="separator:a96fe33567c0c519098b0a70c42d7d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f8c1cd75d74466a6bcbde4e68dd5cb"><td class="memTemplParams" colspan="2">template&lt;size_t Index&gt; </td></tr>
<tr class="memitem:a11f8c1cd75d74466a6bcbde4e68dd5cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">remove_at</a> = typelist::remove_at_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index &gt;</td></tr>
<tr class="memdesc:a11f8c1cd75d74466a6bcbde4e68dd5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with the type at the specified index removed.  <a href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">More...</a><br /></td></tr>
<tr class="separator:a11f8c1cd75d74466a6bcbde4e68dd5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae091b28f06dbd9a2c340ce7c7033f4d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ae091b28f06dbd9a2c340ce7c7033f4d8">remove_duplicates</a> = typelist::remove_duplicates_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> &gt;</td></tr>
<tr class="memdesc:ae091b28f06dbd9a2c340ce7c7033f4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with all duplicates removed &ndash; if a type appeared in the original list multiple times, it will appear in the new list exactly once.  <a href="classmeta_1_1_type_list.html#ae091b28f06dbd9a2c340ce7c7033f4d8">More...</a><br /></td></tr>
<tr class="separator:ae091b28f06dbd9a2c340ce7c7033f4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed45ad6fba302a0521c40f850a6fa9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a51ed45ad6fba302a0521c40f850a6fa9">remove_first</a> = <a class="el" href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">remove_at</a>&lt; 0 &gt;</td></tr>
<tr class="memdesc:a51ed45ad6fba302a0521c40f850a6fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#a51ed45ad6fba302a0521c40f850a6fa9">More...</a><br /></td></tr>
<tr class="separator:a51ed45ad6fba302a0521c40f850a6fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff6fdc23539c764e1718a91e5a5072f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </td></tr>
<tr class="memitem:a0ff6fdc23539c764e1718a91e5a5072f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a0ff6fdc23539c764e1718a91e5a5072f">remove_if</a> = typelist::remove_if_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate &gt;</td></tr>
<tr class="memdesc:a0ff6fdc23539c764e1718a91e5a5072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the predicate for each type in the list, and removes it if the predicate is met.  <a href="classmeta_1_1_type_list.html#a0ff6fdc23539c764e1718a91e5a5072f">More...</a><br /></td></tr>
<tr class="separator:a0ff6fdc23539c764e1718a91e5a5072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01b40f367f1bfe0d384b4355ea4351c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </td></tr>
<tr class="memitem:ab01b40f367f1bfe0d384b4355ea4351c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ab01b40f367f1bfe0d384b4355ea4351c">remove_if_not</a> = typelist::remove_if_not_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate &gt;</td></tr>
<tr class="memdesc:ab01b40f367f1bfe0d384b4355ea4351c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the predicate for each type in the list, and removes it if the predicate is not met.  <a href="classmeta_1_1_type_list.html#ab01b40f367f1bfe0d384b4355ea4351c">More...</a><br /></td></tr>
<tr class="separator:ab01b40f367f1bfe0d384b4355ea4351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da1e6d4d6b90f7b9b08463c0553cfa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ae9da1e6d4d6b90f7b9b08463c0553cfa">remove_last</a> = <a class="el" href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">remove_at</a>&lt; <a class="el" href="classmeta_1_1_type_list.html#ab787551fd9dab3277cb8f9b0a374b547">size</a> - 1 &gt;</td></tr>
<tr class="memdesc:ae9da1e6d4d6b90f7b9b08463c0553cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#ae9da1e6d4d6b90f7b9b08463c0553cfa">More...</a><br /></td></tr>
<tr class="separator:ae9da1e6d4d6b90f7b9b08463c0553cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e483efb883df412e1aa30c3fc4f944"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ae2e483efb883df412e1aa30c3fc4f944">remove_null_types</a> = typelist::remove_null_types_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> &gt;</td></tr>
<tr class="memdesc:ae2e483efb883df412e1aa30c3fc4f944"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any <code>NullType</code> elements are present in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>, removes them.  <a href="classmeta_1_1_type_list.html#ae2e483efb883df412e1aa30c3fc4f944">More...</a><br /></td></tr>
<tr class="separator:ae2e483efb883df412e1aa30c3fc4f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa399e60f7699a3c402cdec27cff9e42"><td class="memTemplParams" colspan="2">template&lt;typename Replace , typename With &gt; </td></tr>
<tr class="memitem:afa399e60f7699a3c402cdec27cff9e42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#afa399e60f7699a3c402cdec27cff9e42">replace</a> = typelist::replace_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Replace, With &gt;</td></tr>
<tr class="memdesc:afa399e60f7699a3c402cdec27cff9e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurances of <code>Replace</code> in the list with <code>With</code>.  <a href="classmeta_1_1_type_list.html#afa399e60f7699a3c402cdec27cff9e42">More...</a><br /></td></tr>
<tr class="separator:afa399e60f7699a3c402cdec27cff9e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97e8449cd5e24f4d23c26d77d98a63d"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename ReplaceWith &gt; </td></tr>
<tr class="memitem:ad97e8449cd5e24f4d23c26d77d98a63d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ad97e8449cd5e24f4d23c26d77d98a63d">replace_at</a> = typelist::replace_at_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index, ReplaceWith &gt;</td></tr>
<tr class="memdesc:ad97e8449cd5e24f4d23c26d77d98a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the type at the specified <code>Index</code> with the new type <code>ReplaceWith</code>.  <a href="classmeta_1_1_type_list.html#ad97e8449cd5e24f4d23c26d77d98a63d">More...</a><br /></td></tr>
<tr class="separator:ad97e8449cd5e24f4d23c26d77d98a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c2c46b73b85991d04cd8559076379e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a54c2c46b73b85991d04cd8559076379e">reverse</a> = typelist::reverse_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> &gt;</td></tr>
<tr class="memdesc:a54c2c46b73b85991d04cd8559076379e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with the same types as this one, but in reverse order.  <a href="classmeta_1_1_type_list.html#a54c2c46b73b85991d04cd8559076379e">More...</a><br /></td></tr>
<tr class="separator:a54c2c46b73b85991d04cd8559076379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832ccde8c6ff4e3732f389ea3fd9891e"><td class="memTemplParams" colspan="2">template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a832ccde8c6ff4e3732f389ea3fd9891e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a832ccde8c6ff4e3732f389ea3fd9891e">swap</a> = typelist::swap_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Type1, Type2 &gt;</td></tr>
<tr class="memdesc:a832ccde8c6ff4e3732f389ea3fd9891e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two types in the list.  <a href="classmeta_1_1_type_list.html#a832ccde8c6ff4e3732f389ea3fd9891e">More...</a><br /></td></tr>
<tr class="separator:a832ccde8c6ff4e3732f389ea3fd9891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3035d4fbdba44d98614dc011e4063"><td class="memTemplParams" colspan="2">template&lt;size_t Index1, size_t Index2&gt; </td></tr>
<tr class="memitem:a34d3035d4fbdba44d98614dc011e4063"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a34d3035d4fbdba44d98614dc011e4063">swap_at</a> = typelist::swap_at_t&lt; <a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index1, Index2 &gt;</td></tr>
<tr class="memdesc:a34d3035d4fbdba44d98614dc011e4063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the types at two indices in the list.  <a href="classmeta_1_1_type_list.html#a34d3035d4fbdba44d98614dc011e4063">More...</a><br /></td></tr>
<tr class="separator:a34d3035d4fbdba44d98614dc011e4063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836ab68533e989626020433ec834a7e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> = <a class="el" href="classmeta_1_1_type_list.html">TypeList</a>&lt; Types... &gt;</td></tr>
<tr class="memdesc:a836ab68533e989626020433ec834a7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can get the fully specialized type of this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> using this alias.  <a href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">More...</a><br /></td></tr>
<tr class="separator:a836ab68533e989626020433ec834a7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a467e671b2bc31135d30f1de3f593c8b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a467e671b2bc31135d30f1de3f593c8b6">TypeList</a> ()=delete</td></tr>
<tr class="memdesc:a467e671b2bc31135d30f1de3f593c8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can't actually create an instance of one, TypeLists are only static objects.  <a href="classmeta_1_1_type_list.html#a467e671b2bc31135d30f1de3f593c8b6">More...</a><br /></td></tr>
<tr class="separator:a467e671b2bc31135d30f1de3f593c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc86b04d569e8b251e0f6dd66571f9ab"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename... Args&gt; </td></tr>
<tr class="memitem:abc86b04d569e8b251e0f6dd66571f9ab"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#abc86b04d569e8b251e0f6dd66571f9ab">construct</a> (Args &amp;&amp;... args) noexcept(noexcept(<a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a>&lt; Index &gt;(std::forward&lt; Args &gt;(args)...)))</td></tr>
<tr class="memdesc:abc86b04d569e8b251e0f6dd66571f9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of the type at the given index in the list.  <a href="classmeta_1_1_type_list.html#abc86b04d569e8b251e0f6dd66571f9ab">More...</a><br /></td></tr>
<tr class="separator:abc86b04d569e8b251e0f6dd66571f9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe887fb18028c143a82c5c2555b14e03"><td class="memTemplParams" colspan="2">template&lt;func::Function Func, typename... Args&gt; </td></tr>
<tr class="memitem:abe887fb18028c143a82c5c2555b14e03"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#abe887fb18028c143a82c5c2555b14e03">for_all</a> (Func &amp;&amp;f, Args &amp;&amp;... args) noexcept(noexcept(f().template operator()&lt;Types... &gt;(std::forward&lt; Args &gt;(args)...))) -&gt; std::invoke_result_t&lt; Func, Args... &gt;</td></tr>
<tr class="memdesc:abe887fb18028c143a82c5c2555b14e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a templated function once, with the template arguments being the types contained in the list.  <a href="classmeta_1_1_type_list.html#abe887fb18028c143a82c5c2555b14e03">More...</a><br /></td></tr>
<tr class="separator:abe887fb18028c143a82c5c2555b14e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15390945a1c28ee8d6da0a243d00276"><td class="memTemplParams" colspan="2">template&lt;func::Function Func, typename... Args&gt; </td></tr>
<tr class="memitem:ac15390945a1c28ee8d6da0a243d00276"><td class="memTemplItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ac15390945a1c28ee8d6da0a243d00276">for_each</a> (Func &amp;&amp;f, Args &amp;&amp;... args) noexcept(noexcept((std::forward&lt; Func &gt;(f).template operator()&lt;Types &gt;(std::forward&lt; Args &gt;(args)...),...)))</td></tr>
<tr class="memdesc:ac15390945a1c28ee8d6da0a243d00276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a templated function for each type in the list.  <a href="classmeta_1_1_type_list.html#ac15390945a1c28ee8d6da0a243d00276">More...</a><br /></td></tr>
<tr class="separator:ac15390945a1c28ee8d6da0a243d00276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569f01767a80822500e7274346552fa2"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename... Args&gt; </td></tr>
<tr class="memitem:a569f01767a80822500e7274346552fa2"><td class="memTemplItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a>&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a569f01767a80822500e7274346552fa2">make_unique</a> (Args &amp;&amp;... args) noexcept(noexcept(<a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a>&lt; Index &gt;(std::forward&lt; Args &gt;(args)...)))</td></tr>
<tr class="memdesc:a569f01767a80822500e7274346552fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <code><a class="el" href="classmeta_1_1_type_list.html#abc86b04d569e8b251e0f6dd66571f9ab" title="Constructs an object of the type at the given index in the list.">construct()</a></code> , except it returns a <code>unique_ptr</code> to the new object.  <a href="classmeta_1_1_type_list.html#a569f01767a80822500e7274346552fa2">More...</a><br /></td></tr>
<tr class="separator:a569f01767a80822500e7274346552fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aec710093f4b29129508715a40c9b7416"><td class="memTemplParams" colspan="2">template&lt;typename... TypesToFind&gt; </td></tr>
<tr class="memitem:aec710093f4b29129508715a40c9b7416"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#aec710093f4b29129508715a40c9b7416">contains</a> = typelist::contains_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToFind...&gt;</td></tr>
<tr class="memdesc:aec710093f4b29129508715a40c9b7416"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all the passed types are contained in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#aec710093f4b29129508715a40c9b7416">More...</a><br /></td></tr>
<tr class="separator:aec710093f4b29129508715a40c9b7416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb221491c37c27717d16a7f739d337e8"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#acb221491c37c27717d16a7f739d337e8">contains_duplicates</a> = typelist::contains_duplicates_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td></tr>
<tr class="memdesc:acb221491c37c27717d16a7f739d337e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if any type appears in the list more than once.  <a href="classmeta_1_1_type_list.html#acb221491c37c27717d16a7f739d337e8">More...</a><br /></td></tr>
<tr class="separator:acb221491c37c27717d16a7f739d337e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3f0625c8839c9df920a9e41d80bfd0"><td class="memTemplParams" colspan="2">template&lt;typename... TypesToFind&gt; </td></tr>
<tr class="memitem:abe3f0625c8839c9df920a9e41d80bfd0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#abe3f0625c8839c9df920a9e41d80bfd0">contains_or</a> = typelist::contains_or_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToFind...&gt;</td></tr>
<tr class="memdesc:abe3f0625c8839c9df920a9e41d80bfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> contains at least one of the passed types.  <a href="classmeta_1_1_type_list.html#abe3f0625c8839c9df920a9e41d80bfd0">More...</a><br /></td></tr>
<tr class="separator:abe3f0625c8839c9df920a9e41d80bfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ed2ea9451f121ce4f9d5bd4b8fa3ce"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </td></tr>
<tr class="memitem:a08ed2ea9451f121ce4f9d5bd4b8fa3ce"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a08ed2ea9451f121ce4f9d5bd4b8fa3ce">count_if</a> = typelist::count_if_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate&gt;</td></tr>
<tr class="memdesc:a08ed2ea9451f121ce4f9d5bd4b8fa3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of types in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that satisfy the predicate.  <a href="classmeta_1_1_type_list.html#a08ed2ea9451f121ce4f9d5bd4b8fa3ce">More...</a><br /></td></tr>
<tr class="separator:a08ed2ea9451f121ce4f9d5bd4b8fa3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a45020f0aca462845094c8f8e79458"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </td></tr>
<tr class="memitem:a99a45020f0aca462845094c8f8e79458"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a99a45020f0aca462845094c8f8e79458">count_if_not</a> = typelist::count_if_not_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate&gt;</td></tr>
<tr class="memdesc:a99a45020f0aca462845094c8f8e79458"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of types in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that do not satisfy the predicate.  <a href="classmeta_1_1_type_list.html#a99a45020f0aca462845094c8f8e79458">More...</a><br /></td></tr>
<tr class="separator:a99a45020f0aca462845094c8f8e79458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba36040537372525b1e5460b42db570"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#adba36040537372525b1e5460b42db570">empty</a> = typelist::is_empty&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td></tr>
<tr class="memdesc:adba36040537372525b1e5460b42db570"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> is empty; false otherwise.  <a href="classmeta_1_1_type_list.html#adba36040537372525b1e5460b42db570">More...</a><br /></td></tr>
<tr class="separator:adba36040537372525b1e5460b42db570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafea4ab27d9d66bdf44edd373f8745b"><td class="memTemplParams" colspan="2">template&lt;class Other &gt; </td></tr>
<tr class="memitem:aeafea4ab27d9d66bdf44edd373f8745b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#aeafea4ab27d9d66bdf44edd373f8745b">equal</a> = typelist::are_same_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td></tr>
<tr class="memdesc:aeafea4ab27d9d66bdf44edd373f8745b"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the other <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> holds the same types in the same order as this one.  <a href="classmeta_1_1_type_list.html#aeafea4ab27d9d66bdf44edd373f8745b">More...</a><br /></td></tr>
<tr class="separator:aeafea4ab27d9d66bdf44edd373f8745b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5fe6d6cc9a1b09a436bb18a907532"><td class="memTemplParams" colspan="2">template&lt;class Other &gt; </td></tr>
<tr class="memitem:a57a5fe6d6cc9a1b09a436bb18a907532"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a57a5fe6d6cc9a1b09a436bb18a907532">equal_ignore_order</a> = typelist::same_ignoring_order_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td></tr>
<tr class="memdesc:a57a5fe6d6cc9a1b09a436bb18a907532"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the other <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> holds the same types as this one, regardless of their order.  <a href="classmeta_1_1_type_list.html#a57a5fe6d6cc9a1b09a436bb18a907532">More...</a><br /></td></tr>
<tr class="separator:a57a5fe6d6cc9a1b09a436bb18a907532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd4d01eb3e616d06d128239da0d353e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:abdd4d01eb3e616d06d128239da0d353e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#abdd4d01eb3e616d06d128239da0d353e">index_of</a> = typelist::find_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Type&gt;</td></tr>
<tr class="memdesc:abdd4d01eb3e616d06d128239da0d353e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the first occurance of the specified type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#abdd4d01eb3e616d06d128239da0d353e">More...</a><br /></td></tr>
<tr class="separator:abdd4d01eb3e616d06d128239da0d353e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9203351b53902bf7c988751d61474f53"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9203351b53902bf7c988751d61474f53"><td class="memTemplItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#a9203351b53902bf7c988751d61474f53">num_of</a> = typelist::count_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Type&gt;</td></tr>
<tr class="memdesc:a9203351b53902bf7c988751d61474f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of times the given type appears in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#a9203351b53902bf7c988751d61474f53">More...</a><br /></td></tr>
<tr class="separator:a9203351b53902bf7c988751d61474f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab787551fd9dab3277cb8f9b0a374b547"><td class="memItemLeft" align="right" valign="top">static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeta_1_1_type_list.html#ab787551fd9dab3277cb8f9b0a374b547">size</a> = typelist::size_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td></tr>
<tr class="memdesc:ab787551fd9dab3277cb8f9b0a374b547"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.  <a href="classmeta_1_1_type_list.html#ab787551fd9dab3277cb8f9b0a374b547">More...</a><br /></td></tr>
<tr class="separator:ab787551fd9dab3277cb8f9b0a374b547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... Types&gt;<br />
class meta::TypeList&lt; Types &gt;</h3>

<p>A compile-time list of types that can be manipulated. </p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyTypeList = TypeList&lt;int, float, double&gt;;</div>
<div class="line"> </div>
<div class="line">static_assert (<a class="code" href="namespacealg.html#aea20a3c576495f7b76380ed04a28b098">MyTypeList::size</a> == 3);</div>
<div class="line">static_assert (MyTypeList::num_of&lt;int&gt; == 1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> FloatingPointTypes = MyTypeList::remove_if_not&lt;std::is_floating_point&gt;;</div>
<div class="line"> </div>
<div class="line">static_assert (FloatingPointTypes::equal&lt;TypeList&lt;float, double&gt;&gt;);</div>
</div><!-- fragment --><p>Most operations on TypeLists are done with using statements, as illustrated above. Once declared, a <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> is immutable; it can only create permutations of itself as new specializations of <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>The list of types for the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> to hold. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00049">49</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a497620ac6e35976d49a8dc897a43c728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497620ac6e35976d49a8dc897a43c728">&#9670;&nbsp;</a></span>add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename... TypesToAdd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a497620ac6e35976d49a8dc897a43c728">add</a> =  typelist::add_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToAdd...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with the given types appended to the end. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TypesToAdd</td><td>Types to add to the end of this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00122">122</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="aaa7aed2a8915342ded7f77d1d4332718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7aed2a8915342ded7f77d1d4332718">&#9670;&nbsp;</a></span>add_from</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;class Other &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#aaa7aed2a8915342ded7f77d1d4332718">add_from</a> =  typelist::add_from_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with types added from another <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Another <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> to add types from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00128">128</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="afda7e9eb484975a96ac7650e2ea4a110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda7e9eb484975a96ac7650e2ea4a110">&#9670;&nbsp;</a></span>addIfAbsent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename... TypesToAdd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#afda7e9eb484975a96ac7650e2ea4a110">addIfAbsent</a> =  typelist::addIfAbsent_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToAdd...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each type in the passed list of types, adds it to the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> if it was not already in the list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TypesToAdd</td><td>List of types to add to the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00134">134</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ae3c811cbb96e424939618e06824bd514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c811cbb96e424939618e06824bd514">&#9670;&nbsp;</a></span>append</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename ToAppend &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ae3c811cbb96e424939618e06824bd514">append</a> =  typelist::append_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, ToAppend&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a type to the end of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<p>This has the same semantics as using add with one passed type, but is provided so that you can be more explicit. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ToAppend</td><td>Type to append to the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00154">154</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a0d0c46f8256995053c560cbf549192a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0c46f8256995053c560cbf549192a2">&#9670;&nbsp;</a></span>apply_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a0d0c46f8256995053c560cbf549192a2">apply_to</a> =  T&lt;Types...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the types in this typelist to another class template, as its template arguments. </p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> TypeListA = TypeList&lt;int, size_t, double, float&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> ExpectedResult = std::variant&lt;int, size_t, double, float&gt;;</div>
<div class="line"> </div>
<div class="line">static_assert (std::is_same_v &lt;TypeListA::apply_to&lt;std::variant&gt;, ExpectedResult&gt;);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Template class to specialize using the types in this list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00307">307</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a3937cad484c565e75f456d1fcee73784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3937cad484c565e75f456d1fcee73784">&#9670;&nbsp;</a></span>at</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a> =  typelist::get_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of an element of the list at the specified index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index in the list to retrieve. A compile-time error will be raised if this index is out of bounds for this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>, unless the list is empty &ndash; if the list is empty, this will always evaluate to NullType. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00177">177</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ab26a020d3c96a0838431334afb15cf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26a020d3c96a0838431334afb15cf3d">&#9670;&nbsp;</a></span>back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ab26a020d3c96a0838431334afb15cf3d">back</a> =  typelist::get_last_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the last element in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<p>This is semantically the same as <code>at&lt;size-1&gt;</code> . </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00187">187</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a665752851436124da071d3aa67c997d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665752851436124da071d3aa67c997d6">&#9670;&nbsp;</a></span>clear</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a665752851436124da071d3aa67c997d6">clear</a> =  <a class="el" href="classmeta_1_1_type_list.html">TypeList</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00068">68</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a1cde21ab3769005ac8f1b0163c970218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cde21ab3769005ac8f1b0163c970218">&#9670;&nbsp;</a></span>common_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;class Other &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a1cde21ab3769005ac8f1b0163c970218">common_with</a> =  typelist::common_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that contains only types that were present in the original list and the passed list <code>Other</code> . </p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> TypeListA = TypeList&lt;int, float, double&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> TypeListB = TypeList&lt;int, double, size_t&gt;;</div>
<div class="line"> </div>
<div class="line">static_assert (TypeListA::common_with&lt;TypeListB&gt;::equal&lt;TypeList&lt;int, double&gt;&gt;);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Another type list to compare this one with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00275">275</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a3461bc7c00934b6b80dcfaeee9a329ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3461bc7c00934b6b80dcfaeee9a329ac">&#9670;&nbsp;</a></span>front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a3461bc7c00934b6b80dcfaeee9a329ac">front</a> =  typelist::get_first_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the first element in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<p>This is semantically the same as <code>at&lt;0&gt;</code> . </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00182">182</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a28862d6c3bb64250c2c4f12347c84d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28862d6c3bb64250c2c4f12347c84d88">&#9670;&nbsp;</a></span>insert_at</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index, typename ToInsert &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a28862d6c3bb64250c2c4f12347c84d88">insert_at</a> =  typelist::insert_at_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index, ToInsert&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> at the given <code>Index</code> . </p>
<p>Types after the given index in the list will be pushed back by 1. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> to insert the new type at. Indices start from 0. </td></tr>
    <tr><td class="paramname">ToInsert</td><td>The type to insert in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00141">141</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a4f923abd9d31f45679cdfe766601bd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f923abd9d31f45679cdfe766601bd4b">&#9670;&nbsp;</a></span>not_in</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;class Other &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a4f923abd9d31f45679cdfe766601bd4b">not_in</a> =  typelist::not_in_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that contains only types that were present in the original list and not in the passed list <code>Other</code> . </p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> TypeListA = TypeList&lt;int, float, double&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> TypeListB = TypeList&lt;int, double, size_t&gt;;</div>
<div class="line"> </div>
<div class="line">static_assert (TypeListA::not_in&lt;TypeListB&gt;::equal&lt;TypeList&lt;float&gt;&gt;);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Another type list to compare this one with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00291">291</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ac3107b564759c17110c888f516c4b893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3107b564759c17110c888f516c4b893">&#9670;&nbsp;</a></span>prepend</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename ToPrepend &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ac3107b564759c17110c888f516c4b893">prepend</a> =  typelist::prepend_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, ToPrepend&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepends a type to the beginning of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ToPrepend</td><td>Type to prepend to the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00147">147</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a96fe33567c0c519098b0a70c42d7d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fe33567c0c519098b0a70c42d7d0fd">&#9670;&nbsp;</a></span>remove</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename... TypesToRemove&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a96fe33567c0c519098b0a70c42d7d0fd">remove</a> =  typelist::remove_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToRemove...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with all occurances of the passed types removed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TypesToRemove</td><td>List of types to remove from the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00203">203</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a11f8c1cd75d74466a6bcbde4e68dd5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f8c1cd75d74466a6bcbde4e68dd5cb">&#9670;&nbsp;</a></span>remove_at</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">remove_at</a> =  typelist::remove_at_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with the type at the specified index removed. </p>
<p>All types after Index in the list will be moved forward by 1. A compile-time error will be raised if the <code>Index</code> is out of range for this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index to remove from the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00216">216</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ae091b28f06dbd9a2c340ce7c7033f4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae091b28f06dbd9a2c340ce7c7033f4d8">&#9670;&nbsp;</a></span>remove_duplicates</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ae091b28f06dbd9a2c340ce7c7033f4d8">remove_duplicates</a> =  typelist::remove_duplicates_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with all duplicates removed &ndash; if a type appeared in the original list multiple times, it will appear in the new list exactly once. </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00259">259</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a51ed45ad6fba302a0521c40f850a6fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ed45ad6fba302a0521c40f850a6fa9">&#9670;&nbsp;</a></span>remove_first</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a51ed45ad6fba302a0521c40f850a6fa9">remove_first</a> =  <a class="el" href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">remove_at</a>&lt;0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first element of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<p>This is semantically the same as <code>remove_at&lt;0&gt;</code> . </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00221">221</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a0ff6fdc23539c764e1718a91e5a5072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff6fdc23539c764e1718a91e5a5072f">&#9670;&nbsp;</a></span>remove_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a0ff6fdc23539c764e1718a91e5a5072f">remove_if</a> =  typelist::remove_if_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the predicate for each type in the list, and removes it if the predicate is met. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>A template class that will be instantiated for each type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> and must provide a compile-time call operator that will determine if the predicate is met for the type it was instantiated with. Examples of unary predicates are <code>std::is_floating_point</code> or <code>std::is_enum</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00232">232</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ab01b40f367f1bfe0d384b4355ea4351c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01b40f367f1bfe0d384b4355ea4351c">&#9670;&nbsp;</a></span>remove_if_not</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ab01b40f367f1bfe0d384b4355ea4351c">remove_if_not</a> =  typelist::remove_if_not_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the predicate for each type in the list, and removes it if the predicate is not met. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>A template class that will be instantiated for each type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> and must provide a compile-time call operator that will determine if the predicate is met for the type it was instantiated with. Examples of unary predicates are <code>std::is_floating_point</code> or <code>std::is_enum</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00238">238</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ae9da1e6d4d6b90f7b9b08463c0553cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9da1e6d4d6b90f7b9b08463c0553cfa">&#9670;&nbsp;</a></span>remove_last</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ae9da1e6d4d6b90f7b9b08463c0553cfa">remove_last</a> =  <a class="el" href="classmeta_1_1_type_list.html#a11f8c1cd75d74466a6bcbde4e68dd5cb">remove_at</a>&lt;<a class="el" href="classmeta_1_1_type_list.html#ab787551fd9dab3277cb8f9b0a374b547">size</a> - 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<p>This is semantically the same as <code>remove_at&lt;size-1&gt;</code> . </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00226">226</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ae2e483efb883df412e1aa30c3fc4f944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e483efb883df412e1aa30c3fc4f944">&#9670;&nbsp;</a></span>remove_null_types</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ae2e483efb883df412e1aa30c3fc4f944">remove_null_types</a> =  typelist::remove_null_types_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If any <code>NullType</code> elements are present in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>, removes them. </p>
<p>This is semantically the same as <code>remove&lt;NullType&gt;</code> . </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00208">208</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="afa399e60f7699a3c402cdec27cff9e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa399e60f7699a3c402cdec27cff9e42">&#9670;&nbsp;</a></span>replace</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename Replace , typename With &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#afa399e60f7699a3c402cdec27cff9e42">replace</a> =  typelist::replace_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Replace, With&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurances of <code>Replace</code> in the list with <code>With</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Replace</td><td>The type to be replaced in the list. A compile-time error will be raised if the list does not contain this type. </td></tr>
    <tr><td class="paramname">With</td><td>The type to replace <code>Replace</code> with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00245">245</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ad97e8449cd5e24f4d23c26d77d98a63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97e8449cd5e24f4d23c26d77d98a63d">&#9670;&nbsp;</a></span>replace_at</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index, typename ReplaceWith &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#ad97e8449cd5e24f4d23c26d77d98a63d">replace_at</a> =  typelist::replace_at_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index, ReplaceWith&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the type at the specified <code>Index</code> with the new type <code>ReplaceWith</code>. </p>
<p>A compile-time error will be raised if the <code>Index</code> is out of range for this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index of the element to be replaced in the list. </td></tr>
    <tr><td class="paramname">ReplaceWith</td><td>The new type to put at index <code>Index</code> in the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00253">253</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a54c2c46b73b85991d04cd8559076379e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c2c46b73b85991d04cd8559076379e">&#9670;&nbsp;</a></span>reverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a54c2c46b73b85991d04cd8559076379e">reverse</a> =  typelist::reverse_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a new <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> with the same types as this one, but in reverse order. </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00190">190</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a832ccde8c6ff4e3732f389ea3fd9891e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832ccde8c6ff4e3732f389ea3fd9891e">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename Type1 , typename Type2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a832ccde8c6ff4e3732f389ea3fd9891e">swap</a> =  typelist::swap_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Type1, Type2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two types in the list. </p>
<p>This finds the first instances of each type in the list, and uses <code>swap_at</code> to swap their indices. A compile-time error will be raised if <code>Type1</code> and <code>Type2</code> are the same type. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type1</td><td>The first type to be swapped. </td></tr>
    <tr><td class="paramname">Type2</td><td>The second type to be swapped. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00171">171</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a34d3035d4fbdba44d98614dc011e4063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d3035d4fbdba44d98614dc011e4063">&#9670;&nbsp;</a></span>swap_at</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index1, size_t Index2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a34d3035d4fbdba44d98614dc011e4063">swap_at</a> =  typelist::swap_at_t&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Index1, Index2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the types at two indices in the list. </p>
<p>A compile-time error will be raised if <code>Index1</code> and <code>Index2</code> are the same. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index1</td><td>The first index to be swapped. </td></tr>
    <tr><td class="paramname">Index2</td><td>The second index to be swapped. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00162">162</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a836ab68533e989626020433ec834a7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836ab68533e989626020433ec834a7e3">&#9670;&nbsp;</a></span>TypeID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a> =  <a class="el" href="classmeta_1_1_type_list.html">TypeList</a>&lt;Types...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can get the fully specialized type of this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> using this alias. </p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyTypeList = TypeList&lt;int&gt;;</div>
<div class="line"> </div>
<div class="line">static_assert (std::is_same_v&lt;MyTypeList::TypeID, TypeList&lt;int&gt;&gt;);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00065">65</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a467e671b2bc31135d30f1de3f593c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467e671b2bc31135d30f1de3f593c8b6">&#9670;&nbsp;</a></span>TypeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::<a class="el" href="classmeta_1_1_type_list.html">TypeList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You can't actually create an instance of one, TypeLists are only static objects. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abc86b04d569e8b251e0f6dd66571f9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc86b04d569e8b251e0f6dd66571f9ab">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a>&lt;Index&gt; <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object of the type at the given index in the list. </p>
<p>If the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> is empty, this will return a <code>NullType</code> object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index in the list of the type to be constructed. A compile-time error will be raised if this index is out of range for the list. </td></tr>
    <tr><td class="paramname">Args</td><td>Constructor arguments for the new object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00315">315</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="abe887fb18028c143a82c5c2555b14e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe887fb18028c143a82c5c2555b14e03">&#9670;&nbsp;</a></span>for_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;func::Function Func, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::for_all </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::invoke_result_t&lt;Func, Args...&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a templated function once, with the template arguments being the types contained in the list. </p>
<p>If the list is empty, the function is called with an empty template parameter list. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Templated function to call. </td></tr>
    <tr><td class="paramname">Args</td><td>Arguments to forward to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return type of the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00348">348</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ac15390945a1c28ee8d6da0a243d00276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15390945a1c28ee8d6da0a243d00276">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;func::Function Func, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a templated function for each type in the list. </p>
<p>If the list is empty, this function does nothing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Templated function to call. </td></tr>
    <tr><td class="paramname">Args</td><td>Arguments to forward to the function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00336">336</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a569f01767a80822500e7274346552fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569f01767a80822500e7274346552fa2">&#9670;&nbsp;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;size_t Index, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classmeta_1_1_type_list.html#a3937cad484c565e75f456d1fcee73784">at</a>&lt;Index&gt; &gt; <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <code><a class="el" href="classmeta_1_1_type_list.html#abc86b04d569e8b251e0f6dd66571f9ab" title="Constructs an object of the type at the given index in the list.">construct()</a></code> , except it returns a <code>unique_ptr</code> to the new object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index in the list of the type to be constructed. A compile-time error will be raised if this index is out of range for the list. </td></tr>
    <tr><td class="paramname">Args</td><td>Constructor arguments for the new object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00325">325</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aec710093f4b29129508715a40c9b7416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec710093f4b29129508715a40c9b7416">&#9670;&nbsp;</a></span>contains</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename... TypesToFind&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::contains = typelist::contains_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToFind...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if all the passed types are contained in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TypesToFind</td><td>List of types to check if this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> contains. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00092">92</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="acb221491c37c27717d16a7f739d337e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb221491c37c27717d16a7f739d337e8">&#9670;&nbsp;</a></span>contains_duplicates</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::contains_duplicates = typelist::contains_duplicates_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if any type appears in the list more than once. </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00256">256</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="abe3f0625c8839c9df920a9e41d80bfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3f0625c8839c9df920a9e41d80bfd0">&#9670;&nbsp;</a></span>contains_or</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename... TypesToFind&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::contains_or = typelist::contains_or_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, TypesToFind...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> contains at least one of the passed types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TypesToFind</td><td>List of types to check if this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> contains. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00098">98</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a08ed2ea9451f121ce4f9d5bd4b8fa3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ed2ea9451f121ce4f9d5bd4b8fa3ce">&#9670;&nbsp;</a></span>count_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::count_if = typelist::count_if_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of types in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that satisfy the predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>A template class that will be instantiated for each type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> and must provide a compile-time call operator that will determine if the predicate is met for the type it was instantiated with. Examples of unary predicates are <code>std::is_floating_point</code> or <code>std::is_enum</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00110">110</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a99a45020f0aca462845094c8f8e79458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a45020f0aca462845094c8f8e79458">&#9670;&nbsp;</a></span>count_if_not</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class UnaryPredicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::count_if_not = typelist::count_if_not_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, UnaryPredicate&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of types in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> that do not satisfy the predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>A template class that will be instantiated for each type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> and must provide a compile-time call operator that will determine if the predicate is met for the type it was instantiated with. Examples of unary predicates are <code>std::is_floating_point</code> or <code>std::is_enum</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00116">116</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="adba36040537372525b1e5460b42db570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba36040537372525b1e5460b42db570">&#9670;&nbsp;</a></span>empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::empty = typelist::is_empty&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> is empty; false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00074">74</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="aeafea4ab27d9d66bdf44edd373f8745b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafea4ab27d9d66bdf44edd373f8745b">&#9670;&nbsp;</a></span>equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;class Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::equal = typelist::are_same_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the other <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> holds the same types in the same order as this one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Another <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00080">80</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a57a5fe6d6cc9a1b09a436bb18a907532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a5fe6d6cc9a1b09a436bb18a907532">&#9670;&nbsp;</a></span>equal_ignore_order</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;class Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::equal_ignore_order = typelist::same_ignoring_order_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Other&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the other <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> holds the same types as this one, regardless of their order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Another <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00086">86</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="abdd4d01eb3e616d06d128239da0d353e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd4d01eb3e616d06d128239da0d353e">&#9670;&nbsp;</a></span>index_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::index_of = typelist::find_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Type&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index of the first occurance of the specified type in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<p>A compile-time error will be raised if the specified type is not in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>, unless the list is empty &ndash; if the list is empty, this will always evaluate to <code>static_cast&lt;size_t&gt;</code>(-1) , regardless of what type was specified. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to find in the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00197">197</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="a9203351b53902bf7c988751d61474f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9203351b53902bf7c988751d61474f53">&#9670;&nbsp;</a></span>num_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::num_of = typelist::count_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>, Type&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of times the given type appears in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to count occurances of in this <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00104">104</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<a id="ab787551fd9dab3277cb8f9b0a374b547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab787551fd9dab3277cb8f9b0a374b547">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const size_t <a class="el" href="classmeta_1_1_type_list.html">meta::TypeList</a>&lt; Types &gt;::size = typelist::size_v&lt;<a class="el" href="classmeta_1_1_type_list.html#a836ab68533e989626020433ec834a7e3">TypeID</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total size of the <a class="el" href="classmeta_1_1_type_list.html" title="A compile-time list of types that can be manipulated.">TypeList</a>. </p>

<p class="definition">Definition at line <a class="el" href="_type_list_8h_source.html#l00071">71</a> of file <a class="el" href="_type_list_8h_source.html">TypeList.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_type_list_8h_source.html">TypeList.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacealg_html_aea20a3c576495f7b76380ed04a28b098"><div class="ttname"><a href="namespacealg.html#aea20a3c576495f7b76380ed04a28b098">alg::size</a></div><div class="ttdeci">constexpr LIMES_EXPORT int size(const ContainerType &amp;container)</div><div class="ttdef"><b>Definition:</b> <a href="_algorithm_8h_source.html#l00138">Algorithm.h:138</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemeta.html">meta</a></li><li class="navelem"><a class="el" href="classmeta_1_1_type_list.html">TypeList</a></li>
    <li class="footer">Generated on Sun May 15 2022 04:08:02 for Limes by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
